rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Default rule: Deny all access
    match /{document=**} {
      allow read, write: if false;
    }
    
    // Public collections - Read only for all users (authenticated and unauthenticated)
    // SRE Fix: Confirmed - No client writes allowed on these collections
    
    // Articles collection (managed by Phase 1 serverless function)
    match /articles/{articleId} {
      allow read: if true;  // Public read access
      allow write: if false;  // No client writes - managed by serverless function
    }
    
    // Market data cache (managed by Phase 2 serverless function)
    match /market_data_cache/{cacheId} {
      allow read: if true;  // Public read access
      allow write: if false;  // No client writes - managed by serverless function
    }
    
    // Market status (managed by Phase 1 serverless function - merged)
    match /market_status/{statusId} {
      allow read: if true;  // Public read access
      allow write: if false;  // No client writes - managed by serverless function
    }
    
    // Sentiment history (managed by Phase 4 serverless function)
    match /sentiment_history/{historyId} {
      allow read: if true;  // Public read access
      allow write: if false;  // No client writes - managed by serverless function
    }
    
    // User-specific collections - Secure access control with data validation
    
    // Users collection with nested watchlist
    match /users/{userId} {
      // User can only access their own user document
      allow read, write: if request.auth != null && request.auth.uid == userId;
      
      // Watchlist subcollection with data validation
      match /watchlist/{tickerDocId} {
        // SRE Fix: Data validation for watchlist items
        allow read: if request.auth != null && request.auth.uid == userId;
        
        allow create: if request.auth != null && 
          request.auth.uid == userId &&
          // Validate ticker field exists and is valid
          resource.data.keys().hasAll(['ticker']) &&
          resource.data.ticker is string &&
          resource.data.ticker.size() <= 10 &&
          resource.data.ticker.size() >= 1 &&
          // Ensure only ticker field is present (no extra data)
          resource.data.keys().size() == 1;
        
        allow update: if request.auth != null && 
          request.auth.uid == userId &&
          // Same validation for updates
          resource.data.keys().hasAll(['ticker']) &&
          resource.data.ticker is string &&
          resource.data.ticker.size() <= 10 &&
          resource.data.ticker.size() >= 1 &&
          resource.data.keys().size() == 1;
        
        allow delete: if request.auth != null && request.auth.uid == userId;
      }
      
      // User preferences subcollection (for future use)
      match /preferences/{preferenceId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
      
      // User activity subcollection (for future use)
      match /activity/{activityId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }
    
    // Feedback collection with rate limiting and data validation
    match /feedback/{feedbackId} {
      // SRE Fix: Rate limiting and data validation for feedback
      allow create: if request.auth != null &&
        // Data validation
        resource.data.keys().hasAll(['message', 'category', 'submittedAt']) &&
        resource.data.message is string &&
        resource.data.message.size() <= 2000 &&
        resource.data.message.size() >= 10 &&
        resource.data.category is string &&
        resource.data.category in ['bug', 'feature', 'general', 'improvement'] &&
        resource.data.submittedAt is timestamp &&
        // Rate limiting: Check if user submitted feedback in last minute
        !exists(/databases/$(database)/documents/feedback/$(request.auth.uid + '_' + resource.data.submittedAt.seconds / 60));
      
      // No read, update, or delete access to protect privacy
      allow read, update, delete: if false;
    }
    
    // Admin collections (for future administrative functions)
    match /admin/{adminDoc} {
      // Only allow access if user has custom admin claim
      allow read, write: if request.auth != null && 
        request.auth.token.admin == true;
    }
    
    // System collections (for internal use)
    match /system/{systemDoc} {
      // No client access - managed by serverless functions only
      allow read, write: if false;
    }
    
    // Analytics collection (for future analytics)
    match /analytics/{analyticsDoc} {
      // Only authenticated users can create analytics events
      allow create: if request.auth != null;
      
      // No read access to protect user privacy
      allow read, update, delete: if false;
    }
    
    // Rate limiting collection (for feedback rate limiting)
    match /rate_limits/{limitId} {
      // Only serverless functions can write to rate limits
      allow read, write: if false;
    }
  }
}
